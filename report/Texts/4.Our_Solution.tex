\section{Our Solution - Multi-Party Computation (MPC)}\label{sec:scheme}

Our approach to ensure trust in the Sphinx header is to prevent user manipulation by decentralizing the header construction to Trusted Third Parties (TTP) through the use of Multi-Party Computaftion (MPC).
\newline

We consider TTPs as \textit{honest-but-curious}.
This means that they follow the protocol correctly but may attempt to infer additional information from the data they process.
Our design ensures that TTPs cannot infer any information about the shared secrets $ s_i $ or the involved mixnodes, even when TTPs collude (except one).
\todo{JT: In the Nym ecosystem, who are the TTPs, who operates them, what exactly are they trusted for?}
\newline

To facilitate explanation and illustration, we describe our solution in the context of a system where each packet goes through a fixed-length path consisting of three mixnodes.
However, the scheme is general and can be adapted to support arbitrary path lengths. 


\subsection{Header structure}

In our approach, each piece of header information is encoded as an elliptic curve point. 
To achieve this, the encoded string is divided into fixed-size chunks, as illustrated in Figure \ref{fig:chunked_schema}, where each chunk is a single EC point. 
For example, in the case of a path consisting of three mixnodes, the resulting header contains seven EC points: one for the destination, one for each mixnode and their integrity tag.

Therefore a method to encode and decode information to and from elliptic curve points is required. 
Specifically, we require a pseudo-random mapping between integers field and curve points group.

Traditional methods achieve this by directly mapping integers to the x-coordinates of points on the curve. 
However, this approach could leaks information by introducing bias since nearby integers result in nearby points.

To address this, we adopt Elligator, which offers stronger privacy guarantees. 
Unlike the traditional approach, Elligator produces a uniformly distributed output which is computationally indistinguishable from truly random curve points. 
This uniformity is critical in our context, where preserving anonymity and avoiding linkability are core goals. 

\subsection{Protocol description}

The overall decentralized scheme is illustrated in Figure~\ref{fig:overall_schema}.  
The client first computes a sequence of shared secrets and then splits these secrets, along with the IP addresses of the mixnodes in the path and the final destination, into $m$ shares.  
Each set of shares is sent to a different TTP, along with the necessary cryptographic element ($\ALPHA$).  
Each TTP independently computes a \textit{partial} Sphinx header using the received shares.  
The client then aggregates these partial headers to reconstruct the final header, ready for transmission through the mixnet.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Images/sphinx_ttp.png}
    \caption{[DRAFT] Overview of the decentralized scheme}
    \label{fig:overall_schema}
\end{figure}\todo{draft image}

\noindent In summary, the protocol is divided into four main steps:
\begin{itemize}
    \item \textbf{Setup}: fixes random points as generators (once but should be refreshed);
    \item \textbf{Client}: splits and shares the necessary information to TTPs;
    \item \textbf{TTP}: encrypts the routing information into a partial header;
    \item \textbf{Mixnode}: decrypts and forwards the header.
\end{itemize}


\subsubsection{Setup}

In our protocol, routing information is divided into seven chunks (see Figure \ref{fig:chunked_schema}), each one encoded into an elliptic curve point. 
These points will later be encrypted by adding a masking point of the form $ P = s G $, where $ s $ is a shared secret and $ G $ is the base generator of the curve.
However, using the same masking point $ P $ for all the seven chunks compromises the \textit{unlinkability} property
(see security note in the TTP step \ref{note:security_why_indep_generators}).

To mitigate this, we use a set of seven \textit{independent} generators $ G_j $, one for each chunk. 
By \textit{independent}, we mean that the scalar relationship between any two generators is unknown. 
Therefore no one knows the scalars $ x_j \in \mathbb{Z}_N $ such that $ G_j = x_j G $.

In principle, this setup phase can be executed only once. 
However, to preserve unlinkability, the set of generators should be refreshed periodically. 
Every entity (clients, mixnodes, and TTPs) must run the setup phase to ensure they use the same set of generators.

To achieve synchronized and deterministic generator values across the system, we derive them from a common seed. 
This seed is computed as the hash of the current timestamp, truncated to the chosen refresh interval. 
To produce distinct seeds for each generator we rehash the seed, or simply increment it since Elligator already provides a uniform (i.e. pseudo-random) integers to points mapping.
\todo[color=blue!30]{In the current implementation, instead of incrementing the seed, we rehash it for each i. However, since Elligator produces uniformly distributed outputs, incrementing may be equally secure and more efficient.}

A subtlety with Elligator is that it can map integers to points outside of the base generator's subgroup.
Thus, an extra step is required to \textit{clear the cofactor} by multiplying the resulting point by the cofactor (Curve25519's cofactor is $ 8 $).

\noindent The final formula for generating the $ j^{th} $ chunk’s generator is:
\begin{equation}
G_j = 8 \cdot H(\text{hash}(\text{timestamp}) + j), \quad \text{for } j = 1, \dots, 7
\end{equation}


\subsubsection{Client}
% 1) Define a destination
% 2) Select a random path
% 3) Select a random salt $x$ (nonce) 
% 4) Generate a chain of shared secret for the path's mixnode
% 5) Transform IP addresses (path's mixnodes and destination) into Point with Elligator and the split those point into shares.
% 6) Split the shared secrets (int) into shares.
% 7) Send sets of shares (mixnodes IPs, destination IP, shared secrets) to different TTP.
% 8) TTP will compute from those shares a partial header and send it to the client. Afterwards, the client aggregate these partial headers.
  
To send a message to a specific destination, the client first randomly chooses a path through the mixnet and generates a nonce.
Using this nonce and the public keys of each mixnode along the path, the client derives a chain of shared secret integers $ (s_1, s_2, s_3) $ as follows:
\begin{equation}
(s_1, s_2, s_3) \quad \left\{ \quad
\begin{aligned}
    \ALPHA_i    &= x_i \, G \\
    S_i         &= x_i \, \text{PK}_i \\
    s_i         &= h(S_i) \\
    r_i         &= \text{hash} ( {\ALPHA_i}_y \ \| \ {S_i}_y ) \\
    x_{i+1}     &= x_i \, r_i \quad (\text{mod}\ N)
\end{aligned}
\right.
\end{equation}
where $ x_1 $ is the client's nonce, $ \text{PK}_i $ is the public key of the $ i^{th} $ mixnode in the path, 
$ N $ is the prime order of the elliptic curve group, $ \| $ is  the concatenation operator and subscript $ y $ refers to the $ y $-coordinate of the point.
The scalar $ r_i $ acts as a pseudo-randomizer to update the secret $ x_i $ for the next hop, 
ensuring that each cryptographic element $ \ALPHA_i $ remains unlinkable across mixnodes.

The IP addresses of the mixnodes and the destination are padded with random bits
then mapped to elliptic curve points using Elligator, allowing later recovery of these addresses.
\todo[color=red!40]{Test code: to verify if the padding is still necessary or optionnal and if limited (max size N)}
Both the resulting IP points and the shared secrets are split into shares and distributed to $ m $ different TTPs. 

Each TTP then independently computes a partial header from the received shares and returns it to the client. 
The client aggregates these partial headers by performing chunkwise point additions to reconstruct the complete encrypted header.
Finally, the client sends the header along with $ \ALPHA_1 $ to the first mixnode from the path. 
\todo[color=blue!30]{Do we need to remind that the user need to encrypt his message using these shared secrets (as in original article) or is uninteresting/obvious enough ?}

\subsubsection{TTP}
% 1) Receive partial destination, path's nodes and partial shared secret
% 2) First
% 3) For each layer
Each TTP receives from the client:
\begin{itemize}
    \item a share of the destination address (EC point),
    \item a share of each mixnode address in the path (EC points),
    \item a share of each shared secrets (integers).
\end{itemize}

The TTP constructs a partial encrypted header by layering routing information in reverse path order, starting from the last mixnode, as illustrated by Figure \ref{fig:chunked_schema}.

At each layer, two new chunks are introduced: the next mixnode’s address (as an EC point) and an integrity tag.  
To preserve a fixed-length header while allowing mixnodes to reverse the operation (as in the original design), four additional \emph{filler chunks} are appended.  
These filler chunks are carefully computed such that at each layer, after applying the corresponding masking points ($s_i \ G_j$), the last two chunks cancel out and become identity point (i.e. point at infinity).  
This mechanism allows these two chunks to be safely truncated at each layer, ensuring a consistent header size while preserving reversibility for mixnodes.

To initialize the header, the TTP encrypts the destination point using the shared secret of the last mixnode and append the required filler chunks. 
Let $ \Delta $ be the partial destination point, $ s_i $ the shared secret corresponding to the $ i^\text{th} $ mixnode in the path, and $ G_j $ the $ j^\text{th} $ chunk's generator. 
The chunks for the last layer (assuming a 3-hop path) are computed as follows:
\begin{equation}
\BETA_3 \quad \left\{ \quad
\begin{aligned}
    {\BETA_3}_1 &= \Delta       + s_3 \ G_1 \\
    {\BETA_3}_2 &= - (s_2 \ G_4 + s_1 \ G_6) \\
    {\BETA_3}_3 &= - (s_2 \ G_5 + s_1 \ G_7) \\
    {\BETA_3}_4 &= - s_2 \ G_6 \\
    {\BETA_3}_5 &= - s_2 \ G_7 \\
\end{aligned}
\right.
\label{eq:last_layer}
\end{equation}

\noindent
Subsequent layers (for $ i = 2 $ and $ i = 1 $) are computed as:
\begin{equation}
\BETA_i \quad \left\{ \quad
\begin{aligned}
    {\BETA_i}_1 &= N_{i+1} + s_i \ G_1\\
    {\BETA_i}_2 &= \GAMMA_{i+1} + s_i \ G_2 \\
    {\BETA_i}_3 &= {\BETA_{i+1}}_1 + s_i \ G_3 \\
    {\BETA_i}_4 &= {\BETA_{i+1}}_2 + s_i \ G_4 \\
    {\BETA_i}_5 &= {\BETA_{i+1}}_3 + s_i \ G_5 \\
\end{aligned}
\right.
\label{eq:layer_i}
\end{equation}

\noindent
For each layer, the integrity tag is computed as:
\begin{equation}
\GAMMA_i = s_i \ G + \sum_{j=1}^{5} {\BETA_i}_j
\label{eq:integrity}
\end{equation}
Here, $ N_{i+1} $ represents the elliptic curve point corresponding to the $ (i+1)^\text{th} $ mixnode in the path.

When the first layer is finally computed, it is appended with the first mixnode’s point $ N_1 $ and the integrity tag $ \GAMMA_1 $.
Finally, the TTP returns the constructed partial header to the client.

\paragraph{\textbf{Security Note.}}\label{note:security_why_indep_generators}
To preserve unlinkability, it is essential that the generators $ (G_1, \dots, G_7) $ are \textit{independent}, meaning that their scalar relationships are unknown and cannot be derived.
If the same generator $ G' $ were used across chunks (or their scalar relationships known), an adversary could compute the chunk-wise difference between consecutive layers: $ {\BETA_i}_j - {\BETA_{i+1}}_j = s_i \ G' $.
Since the shared secret $ s_i $ remains consistent within a layer, the resulting differences would reveal a predictable pattern (uniform or preserved scalar relationships).
This consistency could allow an adversary to correlate incoming and outgoing packets at a mixnode, thereby breaking the unlinkability property.
Using independent generators for each chunk prevents such correlations and is therefore critical to the protocol's security.  

\begin{figure}[H]
    \centering
    \resizebox{0.9\linewidth}{!}{\input{schema/chunkwise_encryption.tex}}
    \caption{Chunkwise header encryption (TTP side)}
    \label{fig:chunked_schema}
\end{figure}


\subsubsection{Mixnode}
% 1) Extract information from the header
% 2) Recompute shared secret
% 3) Integrity check
% 4) Update encrypted information (β)
% 5) Update cryptographic element (α)


When a packet arrives at a mixnode, it begins by extracting the relevant header fields, namely the cryptographic element $ \ALPHA $ and the integrity tag $ \GAMMA $.  
The mixnode then recomputes the shared secret point $ S $ using its private key $ \text{sk} $ and the cryptographic element $ \ALPHA $:  
\begin{equation}
\begin{aligned}
    S &= \text{sk} \ \ALPHA \\
    s &= \text{Elligator}(S)\\
\end{aligned}
\label{eq:derive_secret}
\end{equation}
This point is subsequently mapped to a shared secret integer $ s $ using Elligator.
This shared secret integer is then used to verify the integrity tag: 
\begin{equation}
\GAMMA \overset{\text{?}}{=} s \ G + \sum_{j=1}^{5} \BETA_j
\label{eq:integrity_check}
\end{equation}
The integrity tag is constructed as the sum of the chunks, offset by a secret point derived from the shared secret integer. 
This ensures that only the client and intended mixnode can create, modify, or verify it.
\todo[color=red!50]{Actually, there is a vulnerability since an active adversary could randomly modify the the header and the integrity tag accordingly...}

\noindent If the integrity check passes, the mixnode pads the header by appending two \textit{identity} chunks (i.e. point at infinity) and then updates it as:
\begin{equation}
\BETA'_j = \BETA_j - s \ G_j \qquad \forall j = 1, \dots, 7
\label{eq:decrypt}
\end{equation}

The first chunk ($ \BETA'_1 $), encodes the next mixnode’s IP address. 
This point is mapped back to an integer using Elligator and the random padding is removed by keeping the last 128 bits (i.e. size of an IP address).

\noindent The second chunk ($ \BETA'_2 $) is the new integrity tag ($ \GAMMA' $) for the remaining five chunks that form the new encrypted routing information ($ \BETA' $).

To maintain unlinkability, the cryptographic element $ \ALPHA $ must be updated for the next hop. 
As in the client's step, it is computed using the $y$-coordinates of both $ \ALPHA $ and $ S $:
\begin{equation}
\ALPHA' = \text{hash}(\ALPHA_y \ \| \ S_y) \ \ALPHA
\label{eq:update_alpha}
\end{equation}
Finally, the mixnode forwards the updated header $ (\ALPHA', \GAMMA', \BETA') $ to the next node.

\begin{figure}[H]
    \centering
    \resizebox{0.9\linewidth}{!}{\input{schema/chunkwise_decryption.tex}}
    \caption{Processing sphinx header at mixnode $i$.}
    \label{fig:mixnode_decryption}
\end{figure}

\todo{Do you think it would be easier to understand/visualized the "mixnode step" with this kind of figure ?}

