\section{Introduction}

Mix network, or mixnet, is an overlay network of servers (called mix nodes) that prevent an adversary from correlating senders with receivers~\cite{chaum-mix,cypherpunk-remailer,piotrowska2017loopix,nym-network-whitepaper,danezis2003mixminion, van2015vuvuzela,mixmaster-spec,chaum2016cmix}. They achieve this by adding delays to messages inside the different mixnodes in order to mitigate timing analysis attacks. Additionally, unlike Tor~\cite{onion-routing96} where all packets sent by a user follow the same path for the entire session (called circuit-based), in mixnets routing is typically packet-based (meaning that each packet follows a different path). These two techniques ensure that mixnets are resilient against a strong adversary who observes the entire input and outputs of the network typically called a Global Passive Adversary (GPA).
During the last few decades several systems have been proposed in the literature and few of them have been implemented. Open research problems such as parametrization, authentication and fake dummies have halted the usage on a large scale. Recently, Nym Technologies a mixnet-based company is being commercialized and proposing a mixnet network for services to be integrated with their network for a fee. Their network is based on Loopix~\cite{piotrowska2017loopix}. Users of these services are then allowed to use the nym mixnet by using Nym credentials (based on the Coconut credential~\cite{coconut}) that they can construct after getting a certificate of paying for a specific service to use the Nym network. However, nothing prevents users from cheating who might exploit a valid Nym credential for another service they did not pay for. This is a particular difficult problem in anonymous communication networks where the mixnodes do not know the traffic type or the final service a user is communicating with by doing layered encryption where the final IP address is only know by the last node in the path using a packer format such as Sphinx~\cite{sphinx}. 
\newline
In this paper we present a scheme that creates the Sphinx header in a decentralized way based on trusted third parties while ensuring they learn nothing about the destination or the path. We aim to provide the following properties:
\todo{Aurelien: We could be more concise on the 'properties' in the introduction and reintroduced them in the threat model section}
\begin{itemize}
	\item Cheating users: Users's traffic is only allowed to be routed if the traffic belongs to the same service provider from the credential
	\item even if the majority of headers issuers are colluding, they do not know which service provider the user is communicating with.
	\item the spinx headers can not be altered.
	\item Verifiers can verify that the headers has not been altered without revealing the service provider.
	\item Unlinkability between  sphinx packets, the original sphinx packet that is constructed in a centralized way provide the \textit{unlinkability} property, meaning that an adversary can not know that two packets are connected to the same user. Our scheme that decentralize the headers creation aim at providing this same property.
\end{itemize}
We highlight related work and motivation in Section~\ref{sec:related}, then we specify and justify our system model in Section~\ref{sec:sys_model}, where we also describe the considered threat model. We then present our scheme that decentralize the creation of the Sphinx headers in Section~\ref{sec:scheme} and the evaluation of our proposed solution in Section~\ref{sec:eval}. Finally we conclude and discuss future work in Section~\ref{sec:conclusion}